import type { TrialBalanceData, MappedTrialBalance } from '../types/project';

/**
 * Statement Linking and Cross-References System
 * Provides automatic linking between related statement items, drill-down capabilities,
 * and statement reconciliation features
 */

export interface CrossReference {
  id: string;
  fromStatement: StatementType;
  fromLineId: string;
  toStatement: StatementType;
  toLineId: string;
  relationship: RelationshipType;
  amount: number;
  description: string;
  autoGenerated: boolean;
}

export interface DrillDownPath {
  statement: StatementType;
  lineId: string;
  label: string;
  amount: number;
  level: number;
  children?: DrillDownPath[];
}

export interface ReconciliationItem {
  id: string;
  description: string;
  amount: number;
  source: {
    statement: StatementType;
    lineId: string;
  };
  target: {
    statement: StatementType;
    lineId: string;
  };
  variance: number;
  status: 'matched' | 'variance' | 'missing';
  tolerance: number;
}

export interface StatementLinks {
  crossReferences: CrossReference[];
  drillDownPaths: Record<string, DrillDownPath[]>;
  reconciliations: ReconciliationItem[];
  noteReferences: NoteReference[];
}

export interface NoteReference {
  id: string;
  statementType: StatementType;
  lineId: string;
  noteNumber: number;
  noteTitle: string;
  noteContent?: string;
  mandatory: boolean;
}

export const StatementType = {
  STATEMENT_OF_FINANCIAL_POSITION: 'sfp',
  STATEMENT_OF_PROFIT_OR_LOSS: 'spl',
  STATEMENT_OF_CASH_FLOWS: 'scf',
  STATEMENT_OF_CHANGES_IN_EQUITY: 'soce',
  NOTES: 'notes'
} as const;

export type StatementType = typeof StatementType[keyof typeof StatementType];

export const RelationshipType = {
  BALANCES_TO: 'balances_to',
  DERIVED_FROM: 'derived_from',
  RECONCILES_WITH: 'reconciles_with',
  MOVEMENT_IN: 'movement_in',
  BREAKDOWN_OF: 'breakdown_of',
  SUBTOTAL_OF: 'subtotal_of'
} as const;

export type RelationshipType = typeof RelationshipType[keyof typeof RelationshipType];

/**
 * Main class for managing statement links and cross-references
 */
export class StatementLinker {
  private mappedTrialBalance: MappedTrialBalance;
  private links: StatementLinks;

  constructor(_trialBalance: TrialBalanceData, mappedTrialBalance: MappedTrialBalance) {
    this.mappedTrialBalance = mappedTrialBalance;
    this.links = {
      crossReferences: [],
      drillDownPaths: {},
      reconciliations: [],
      noteReferences: []
    };
  }

  /**
   * Generate all automatic links between statements
   */
  public generateAllLinks(): StatementLinks {
    this.generateCrossReferences();
    this.generateDrillDownPaths();
    this.generateReconciliations();
    this.generateNoteReferences();
    return this.links;
  }

  /**
   * Generate cross-references between statements
   */
  private generateCrossReferences(): void {
    // SFP to SOCE links
    this.addCrossReference(
      StatementType.STATEMENT_OF_FINANCIAL_POSITION, 'equity',
      StatementType.STATEMENT_OF_CHANGES_IN_EQUITY, 'total',
      RelationshipType.BALANCES_TO,
      'Total equity balances between SFP and SOCE'
    );

    this.addCrossReference(
      StatementType.STATEMENT_OF_FINANCIAL_POSITION, 'retainedEarnings',
      StatementType.STATEMENT_OF_CHANGES_IN_EQUITY, 'retainedEarnings',
      RelationshipType.BALANCES_TO,
      'Retained earnings balance'
    );

    // SPL to SOCE links
    this.addCrossReference(
      StatementType.STATEMENT_OF_PROFIT_OR_LOSS, 'netIncome',
      StatementType.STATEMENT_OF_CHANGES_IN_EQUITY, 'profit',
      RelationshipType.MOVEMENT_IN,
      'Net income flows to retained earnings'
    );

    // SCF to other statements
    this.addCrossReference(
      StatementType.STATEMENT_OF_CASH_FLOWS, 'netCashFromOperating',
      StatementType.STATEMENT_OF_PROFIT_OR_LOSS, 'netIncome',
      RelationshipType.DERIVED_FROM,
      'Operating cash flow derived from net income'
    );

    this.addCrossReference(
      StatementType.STATEMENT_OF_CASH_FLOWS, 'cashAtEnd',
      StatementType.STATEMENT_OF_FINANCIAL_POSITION, 'cash',
      RelationshipType.BALANCES_TO,
      'Cash at end of period balances to SFP'
    );

    // Additional cross-references
    this.generateDetailedCrossReferences();
  }

  private generateDetailedCrossReferences(): void {
    // Property, Plant & Equipment movements
    if (this.mappedTrialBalance.assets && this.mappedTrialBalance.assets['Property, Plant and Equipment']) {
      this.addCrossReference(
        StatementType.STATEMENT_OF_FINANCIAL_POSITION, 'ppe',
        StatementType.STATEMENT_OF_CASH_FLOWS, 'investingActivities',
        RelationshipType.MOVEMENT_IN,
        'PPE movements reflected in investing activities'
      );
    }

    // Debt movements
    if (this.mappedTrialBalance.liabilities) {
      this.addCrossReference(
        StatementType.STATEMENT_OF_FINANCIAL_POSITION, 'longTermDebt',
        StatementType.STATEMENT_OF_CASH_FLOWS, 'financingActivities',
        RelationshipType.MOVEMENT_IN,
        'Debt movements in financing activities'
      );
    }

    // Depreciation
    this.addCrossReference(
      StatementType.STATEMENT_OF_PROFIT_OR_LOSS, 'depreciation',
      StatementType.STATEMENT_OF_CASH_FLOWS, 'depreciation',
      RelationshipType.RECONCILES_WITH,
      'Depreciation expense reconciliation'
    );
  }

  /**
   * Generate drill-down paths for detailed analysis
   */
  private generateDrillDownPaths(): void {
    // Revenue drill-down
    this.createDrillDownPath('revenue', [
      { statement: StatementType.STATEMENT_OF_PROFIT_OR_LOSS, lineId: 'revenue', label: 'Total Revenue' },
      { statement: StatementType.NOTES, lineId: 'revenueBySegment', label: 'Revenue by Segment' },
      { statement: StatementType.NOTES, lineId: 'revenueByProduct', label: 'Revenue by Product' },
      { statement: StatementType.NOTES, lineId: 'revenueByRegion', label: 'Revenue by Region' }
    ]);

    // Current assets drill-down
    this.createDrillDownPath('currentAssets', [
      { statement: StatementType.STATEMENT_OF_FINANCIAL_POSITION, lineId: 'currentAssets', label: 'Current Assets' },
      { statement: StatementType.STATEMENT_OF_FINANCIAL_POSITION, lineId: 'cash', label: 'Cash and Cash Equivalents' },
      { statement: StatementType.STATEMENT_OF_FINANCIAL_POSITION, lineId: 'accountsReceivable', label: 'Accounts Receivable' },
      { statement: StatementType.STATEMENT_OF_FINANCIAL_POSITION, lineId: 'inventory', label: 'Inventory' },
      { statement: StatementType.NOTES, lineId: 'inventoryBreakdown', label: 'Inventory Breakdown' }
    ]);

    // Operating expenses drill-down
    this.createDrillDownPath('operatingExpenses', [
      { statement: StatementType.STATEMENT_OF_PROFIT_OR_LOSS, lineId: 'operatingExpenses', label: 'Operating Expenses' },
      { statement: StatementType.NOTES, lineId: 'employeeBenefits', label: 'Employee Benefits' },
      { statement: StatementType.NOTES, lineId: 'depreciation', label: 'Depreciation and Amortization' },
      { statement: StatementType.NOTES, lineId: 'otherExpenses', label: 'Other Operating Expenses' }
    ]);
  }

  /**
   * Generate reconciliation items
   */
  private generateReconciliations(): void {
    const tolerance = 0.01; // 1 cent tolerance

    // Cash reconciliation
    this.addReconciliation(
      'cash-reconciliation',
      'Cash balance reconciliation',
      StatementType.STATEMENT_OF_FINANCIAL_POSITION, 'cash',
      StatementType.STATEMENT_OF_CASH_FLOWS, 'cashAtEnd',
      tolerance
    );

    // Equity reconciliation
    this.addReconciliation(
      'equity-reconciliation',
      'Total equity reconciliation',
      StatementType.STATEMENT_OF_FINANCIAL_POSITION, 'totalEquity',
      StatementType.STATEMENT_OF_CHANGES_IN_EQUITY, 'closingBalance',
      tolerance
    );

    // Profit reconciliation
    this.addReconciliation(
      'profit-reconciliation',
      'Net profit reconciliation',
      StatementType.STATEMENT_OF_PROFIT_OR_LOSS, 'netIncome',
      StatementType.STATEMENT_OF_CHANGES_IN_EQUITY, 'profitForYear',
      tolerance
    );

    // Working capital reconciliation
    this.generateWorkingCapitalReconciliation(tolerance);
  }

  /**
   * Generate note references
   */
  private generateNoteReferences(): void {
    // Mandatory note references
    this.addNoteReference(StatementType.STATEMENT_OF_FINANCIAL_POSITION, 'ppe', 1, 'Property, Plant and Equipment', true);
    this.addNoteReference(StatementType.STATEMENT_OF_FINANCIAL_POSITION, 'inventory', 2, 'Inventories', true);
    this.addNoteReference(StatementType.STATEMENT_OF_FINANCIAL_POSITION, 'accountsReceivable', 3, 'Trade and Other Receivables', true);
    this.addNoteReference(StatementType.STATEMENT_OF_PROFIT_OR_LOSS, 'revenue', 4, 'Revenue', true);
    this.addNoteReference(StatementType.STATEMENT_OF_PROFIT_OR_LOSS, 'operatingExpenses', 5, 'Operating Expenses', true);
    this.addNoteReference(StatementType.STATEMENT_OF_FINANCIAL_POSITION, 'borrowings', 6, 'Borrowings', true);
    this.addNoteReference(StatementType.STATEMENT_OF_CHANGES_IN_EQUITY, 'shareCapital', 7, 'Share Capital', true);

    // Optional note references
    this.addNoteReference(StatementType.STATEMENT_OF_PROFIT_OR_LOSS, 'financeCosts', 8, 'Finance Costs', false);
    this.addNoteReference(StatementType.STATEMENT_OF_PROFIT_OR_LOSS, 'incomeTax', 9, 'Income Tax', false);
    this.addNoteReference(StatementType.STATEMENT_OF_CASH_FLOWS, 'operatingActivities', 10, 'Cash Flows from Operating Activities', false);
  }

  private addCrossReference(
    fromStatement: StatementType,
    fromLineId: string,
    toStatement: StatementType,
    toLineId: string,
    relationship: RelationshipType,
    description: string
  ): void {
    const fromAmount = this.getLineAmount(fromStatement, fromLineId);
    
    this.links.crossReferences.push({
      id: `${fromStatement}-${fromLineId}-to-${toStatement}-${toLineId}`,
      fromStatement,
      fromLineId,
      toStatement,
      toLineId,
      relationship,
      amount: fromAmount,
      description,
      autoGenerated: true
    });
  }

  private createDrillDownPath(pathId: string, steps: Omit<DrillDownPath, 'amount' | 'level' | 'children'>[]): void {
    const drillDownPath: DrillDownPath[] = steps.map((step, index) => ({
      ...step,
      amount: this.getLineAmount(step.statement, step.lineId),
      level: index,
      children: index === steps.length - 1 ? [] : undefined
    }));

    this.links.drillDownPaths[pathId] = drillDownPath;
  }

  private addReconciliation(
    id: string,
    description: string,
    sourceStatement: StatementType,
    sourceLineId: string,
    targetStatement: StatementType,
    targetLineId: string,
    tolerance: number
  ): void {
    const sourceAmount = this.getLineAmount(sourceStatement, sourceLineId);
    const targetAmount = this.getLineAmount(targetStatement, targetLineId);
    const variance = Math.abs(sourceAmount - targetAmount);
    
    this.links.reconciliations.push({
      id,
      description,
      amount: sourceAmount,
      source: { statement: sourceStatement, lineId: sourceLineId },
      target: { statement: targetStatement, lineId: targetLineId },
      variance,
      status: variance <= tolerance ? 'matched' : 'variance',
      tolerance
    });
  }

  private addNoteReference(
    statementType: StatementType,
    lineId: string,
    noteNumber: number,
    noteTitle: string,
    mandatory: boolean
  ): void {
    this.links.noteReferences.push({
      id: `${statementType}-${lineId}-note-${noteNumber}`,
      statementType,
      lineId,
      noteNumber,
      noteTitle,
      mandatory
    });
  }

  private generateWorkingCapitalReconciliation(tolerance: number): void {
    // Calculate working capital from SFP
    const currentAssets = this.getLineAmount(StatementType.STATEMENT_OF_FINANCIAL_POSITION, 'currentAssets');
    const currentLiabilities = this.getLineAmount(StatementType.STATEMENT_OF_FINANCIAL_POSITION, 'currentLiabilities');
    const workingCapitalSFP = currentAssets - currentLiabilities;

    // Working capital changes should reconcile with cash flow statement
    const workingCapitalChange = this.getLineAmount(StatementType.STATEMENT_OF_CASH_FLOWS, 'workingCapitalChanges');

    this.links.reconciliations.push({
      id: 'working-capital-analysis',
      description: 'Working capital movement analysis',
      amount: workingCapitalSFP,
      source: { statement: StatementType.STATEMENT_OF_FINANCIAL_POSITION, lineId: 'workingCapital' },
      target: { statement: StatementType.STATEMENT_OF_CASH_FLOWS, lineId: 'workingCapitalChanges' },
      variance: Math.abs(workingCapitalChange),
      status: 'matched', // This would be calculated based on period-over-period changes
      tolerance
    });
  }

  private getLineAmount(statement: StatementType, lineId: string): number {
    // Extract amounts from the mapped trial balance based on statement type and line ID
    try {
      switch (statement) {
        case StatementType.STATEMENT_OF_FINANCIAL_POSITION:
          return this.getBalanceSheetAmount(lineId);
        case StatementType.STATEMENT_OF_PROFIT_OR_LOSS:
          return this.getIncomeStatementAmount(lineId);
        case StatementType.STATEMENT_OF_CASH_FLOWS:
          return this.getCashFlowAmount(lineId);
        case StatementType.STATEMENT_OF_CHANGES_IN_EQUITY:
          return this.getEquityAmount(lineId);
        default:
          return 0;
      }
    } catch {
      // Return 0 if unable to extract amount
      return 0;
    }
  }

  private getBalanceSheetAmount(lineId: string): number {
    const { assets, liabilities, equity } = this.mappedTrialBalance;
    
    switch (lineId) {
      case 'currentAssets':
        return this.calculateSectionTotal(assets?.['Current Assets']);
      case 'cash':
        return this.calculateSectionTotal(assets?.['Cash and Cash Equivalents']);
      case 'accountsReceivable':
        return this.calculateSectionTotal(assets?.['Trade and Other Receivables']);
      case 'inventory':
        return this.calculateSectionTotal(assets?.['Inventories']);
      case 'ppe':
        return this.calculateSectionTotal(assets?.['Property, Plant and Equipment']);
      case 'currentLiabilities':
        return this.calculateSectionTotal(liabilities?.['Current Liabilities']);
      case 'longTermDebt':
        return this.calculateSectionTotal(liabilities?.['Non-Current Liabilities']);
      case 'totalEquity':
      case 'equity':
        return this.calculateSectionTotal(equity);
      case 'retainedEarnings':
        return this.calculateSectionTotal(equity?.['Retained Earnings']);
      default:
        return 0;
    }
  }

  private getIncomeStatementAmount(lineId: string): number {
    const { revenue, expenses } = this.mappedTrialBalance;
    
    switch (lineId) {
      case 'revenue':
        return this.calculateSectionTotal(revenue);
      case 'operatingExpenses':
        return this.calculateSectionTotal(expenses?.['Operating Expenses']);
      case 'depreciation':
        return this.calculateSectionTotal(expenses?.['Depreciation and Amortisation']);
      case 'financeCosts':
        return this.calculateSectionTotal(expenses?.['Finance Costs']);
      case 'incomeTax':
        return this.calculateSectionTotal(expenses?.['Income Tax Expense']);
      case 'netIncome': {
        const totalRevenue = this.calculateSectionTotal(revenue);
        const totalExpenses = this.calculateSectionTotal(expenses);
        return totalRevenue + totalExpenses; // Expenses are typically negative
      }
      default:
        return 0;
    }
  }

  private getCashFlowAmount(lineId: string): number {
    // Cash flow amounts would need to be calculated or extracted from cash flow statement
    // For now, return 0 as this would require additional cash flow calculation logic
    switch (lineId) {
      case 'cashAtEnd':
        return this.getBalanceSheetAmount('cash');
      case 'netCashFromOperating':
      case 'investingActivities':
      case 'financingActivities':
      case 'workingCapitalChanges':
      default:
        return 0;
    }
  }

  private getEquityAmount(lineId: string): number {
    const { equity } = this.mappedTrialBalance;
    
    switch (lineId) {
      case 'total':
      case 'closingBalance':
        return this.calculateSectionTotal(equity);
      case 'retainedEarnings':
        return this.calculateSectionTotal(equity?.['Retained Earnings']);
      case 'shareCapital':
        return this.calculateSectionTotal(equity?.['Share Capital']);
      case 'profit':
      case 'profitForYear':
        return this.getIncomeStatementAmount('netIncome');
      default:
        return 0;
    }
  }

  private calculateSectionTotal(section: unknown): number {
    if (!section) return 0;
    
    if (Array.isArray(section)) {
      return section.reduce((total, account) => {
        return total + (account.debit - account.credit);
      }, 0);
    }
    
    if (typeof section === 'object') {
      return Object.values(section as Record<string, unknown>).reduce((total: number, accounts: unknown) => {
        if (Array.isArray(accounts)) {
          return total + accounts.reduce((subTotal, account) => {
            return subTotal + (account.debit - account.credit);
          }, 0);
        }
        return total;
      }, 0);
    }
    
    return 0;
  }

  /**
   * Get cross-references for a specific line item
   */
  public getCrossReferencesForLine(statement: StatementType, lineId: string): CrossReference[] {
    return this.links.crossReferences.filter(
      ref => (ref.fromStatement === statement && ref.fromLineId === lineId) ||
             (ref.toStatement === statement && ref.toLineId === lineId)
    );
  }

  /**
   * Get drill-down path for a line item
   */
  public getDrillDownPath(lineId: string): DrillDownPath[] | undefined {
    return this.links.drillDownPaths[lineId];
  }

  /**
   * Get reconciliation items with variances
   */
  public getReconciliationVariances(): ReconciliationItem[] {
    return this.links.reconciliations.filter(item => item.status === 'variance');
  }

  /**
   * Get mandatory note references
   */
  public getMandatoryNoteReferences(): NoteReference[] {
    return this.links.noteReferences.filter(ref => ref.mandatory);
  }

  /**
   * Validate all reconciliations
   */
  public validateReconciliations(): {
    passed: ReconciliationItem[];
    failed: ReconciliationItem[];
    totalVariance: number;
  } {
    const passed = this.links.reconciliations.filter(item => item.status === 'matched');
    const failed = this.links.reconciliations.filter(item => item.status === 'variance');
    const totalVariance = failed.reduce((sum, item) => sum + item.variance, 0);

    return { passed, failed, totalVariance };
  }
}

/**
 * Utility functions for statement linking
 */
export function createStatementLinker(
  trialBalance: TrialBalanceData,
  mappedTrialBalance: MappedTrialBalance
): StatementLinker {
  return new StatementLinker(trialBalance, mappedTrialBalance);
}

export function generateStatementLinks(
  trialBalance: TrialBalanceData,
  mappedTrialBalance: MappedTrialBalance
): StatementLinks {
  const linker = createStatementLinker(trialBalance, mappedTrialBalance);
  return linker.generateAllLinks();
}

/**
 * Format cross-reference for display
 */
export function formatCrossReference(crossRef: CrossReference): string {
  const relationshipText = {
    [RelationshipType.BALANCES_TO]: 'balances to',
    [RelationshipType.DERIVED_FROM]: 'is derived from',
    [RelationshipType.RECONCILES_WITH]: 'reconciles with',
    [RelationshipType.MOVEMENT_IN]: 'represents movement in',
    [RelationshipType.BREAKDOWN_OF]: 'is a breakdown of',
    [RelationshipType.SUBTOTAL_OF]: 'is a subtotal of'
  };

  return `${crossRef.fromStatement}.${crossRef.fromLineId} ${relationshipText[crossRef.relationship]} ${crossRef.toStatement}.${crossRef.toLineId}`;
}

/**
 * Generate reconciliation report
 */
export function generateReconciliationReport(links: StatementLinks): {
  summary: string;
  details: ReconciliationItem[];
  recommendations: string[];
} {
  const failed = links.reconciliations.filter(item => item.status === 'variance');
  const totalVariance = failed.reduce((sum, item) => sum + item.variance, 0);
  
  const summary = `${links.reconciliations.length} reconciliation items checked. ${failed.length} variances found totaling ${totalVariance.toFixed(2)}.`;
  
  const recommendations: string[] = [];
  if (failed.length > 0) {
    recommendations.push('Review reconciliation variances and investigate root causes');
    recommendations.push('Verify trial balance mappings for items with variances');
    recommendations.push('Consider adjusting tolerance levels if variances are immaterial');
  }

  return {
    summary,
    details: failed,
    recommendations
  };
}
